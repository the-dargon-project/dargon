using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using Dargon.Commons;
using Microsoft.CodeAnalysis;

namespace Dargon.Vox.SourceGenerators {
   public static class VSGErrors {
      public static string Category = "Vox";

      public static string EnumsMustBeViaRedirectToType = "VOX001";
      public static string EnumsMustBeViaRedirectToTypeMessageTitle(string enumName) => $"Enum '{enumName}' cannot have VoxTypeAttribute. Use a redirect class instead!";
   }

   [Generator]
   public class VoxSourceGenerator : ISourceGenerator {
      public void Initialize(GeneratorInitializationContext context) {
         if (!Debugger.IsAttached) {
            //Debugger.Launch();
         }  
      }

      public void Execute(GeneratorExecutionContext context) {
         try {
            ExecuteInternal(context);
         } catch (Exception e) {
            // See 
            context.ReportDiagnostic(Diagnostic.Create(
               new DiagnosticDescriptor(
                  "VOX000",
                  $"An exception was thrown by {nameof(VoxSourceGenerator)}",
                  $"An exception was thrown by {nameof(VoxSourceGenerator)}: '{e}'",
                  "Vox",
                  DiagnosticSeverity.Error,
                  isEnabledByDefault: true),
               Location.None,
               e.ToString()));
         }
      }

      public class KnownTypes {
         public KnownTypes(GeneratorExecutionContext context) {
            AllNamedTypes = RoslynUtils.EnumerateNamedTypeSymbols(context.Compilation.GlobalNamespace).ToList();
            VoxInternalBaseDummyType = AllNamedTypes.First(t => t.Name == "VoxInternalBaseDummyType");
            VoxInternalBaseAttribute = AllNamedTypes.First(t => t.Name == "VoxInternalBaseAttribute");
            AllVoxTypeAttributes = RoslynUtils.FilterTypeDescendentsAndSelf(AllNamedTypes, VoxInternalBaseAttribute);
            AllVoxDummyTypes = RoslynUtils.FilterTypeDescendentsAndSelf(AllNamedTypes, VoxInternalBaseDummyType);
            AllVoxAnnotationTypes = AllVoxTypeAttributes.Concat(AllVoxDummyTypes).ToList();
            VoxTypeAttributeType = AllNamedTypes.First(t => t.Name == "VoxTypeAttribute");

            SyntaxTreeToTypeAndVoxTypeAttribute =
               AllNamedTypes.Where(t => t.TypeKind == TypeKind.Class || t.TypeKind == TypeKind.Struct || t.TypeKind == TypeKind.Enum)
                            .SelectPairValue(t => RoslynUtils.FindAnyAttributeOrDefault(t, AllVoxTypeAttributes))
                            .Where(kvp => kvp.Value != null)
                            .Where(kvp => kvp.Value.ApplicationSyntaxReference != null) // null if from dependency project
                            .Where(kvp => context.Compilation.ContainsSyntaxTree(kvp.Value.ApplicationSyntaxReference.SyntaxTree)) // don't include if out of compilation (e.g. generated by another compilation's source generator)
                            .GroupBy(kvp => kvp.Value.ApplicationSyntaxReference.SyntaxTree.AssertIsNotNull())
                            .Select(g => new KeyValuePair<SyntaxTree, List<KeyValuePair<INamedTypeSymbol, AttributeData>>>(g.Key, g.ToList()))
                            .ToList();
         }

         public List<INamedTypeSymbol> AllNamedTypes { get; }
         public INamedTypeSymbol VoxInternalBaseDummyType { get; }
         public INamedTypeSymbol VoxInternalBaseAttribute { get; }
         public List<INamedTypeSymbol> AllVoxTypeAttributes { get; }
         public List<INamedTypeSymbol> AllVoxDummyTypes { get; }
         public List<INamedTypeSymbol> AllVoxAnnotationTypes { get; }
         public INamedTypeSymbol VoxTypeAttributeType { get; }
         public List<KeyValuePair<SyntaxTree, List<KeyValuePair<INamedTypeSymbol, AttributeData>>>> SyntaxTreeToTypeAndVoxTypeAttribute { get; }

      }

      private void ExecuteInternal(GeneratorExecutionContext context) {
         var types = new KnownTypes(context);

         foreach (var (syntaxTree, entries) in types.SyntaxTreeToTypeAndVoxTypeAttribute) {
            new VoxTypePartialSourceEmitter(types, syntaxTree, entries).X(context);
         }
      }
   }

   public class VoxTypePartialSourceEmitter {
      private const char dq = '"';

      private readonly VoxSourceGenerator.KnownTypes types;
      private readonly SyntaxTree syntaxTree;
      private readonly List<KeyValuePair<INamedTypeSymbol, AttributeData>> entries;

      public VoxTypePartialSourceEmitter(VoxSourceGenerator.KnownTypes types, SyntaxTree syntaxTree, List<KeyValuePair<INamedTypeSymbol, AttributeData>> entries) {
         this.types = types;
         this.syntaxTree = syntaxTree;
         this.entries = entries;
      }

      private readonly HashSet<string> allUsingImports = new HashSet<string>();

      private readonly HashSet<string> knownDependencySerializerNames = new HashSet<string>();
      private readonly StringBuilder dependencySerializerFieldDeclarationsSb = new StringBuilder();
      private readonly StringBuilder dependencySerializerFieldInitializersSb = new StringBuilder();

      private void HandleBeginNewTypeProcess() {
         knownDependencySerializerNames.Clear();
         dependencySerializerFieldDeclarationsSb.Clear();
         dependencySerializerFieldInitializersSb.Clear();
      }

      private string GetDependencySerializerName(ITypeSymbol ts) {
         var ds = ts.ToDisplayString();
         var name = ds.Replace(":", "_").Replace(".", "_").Replace("<", "1337").Replace(">", "1338").Replace(",", "_").Replace(" ", "");
         var serializerName = $"_dep_{name}";
         
         if (knownDependencySerializerNames.Add(serializerName)) {
            dependencySerializerFieldDeclarationsSb.AppendLine($"private IVoxSerializer<{ds}> {serializerName};");
            dependencySerializerFieldInitializersSb.AppendLine($"{serializerName} = vsc.GetSerializerForType<{ds}>();");
         }

         return serializerName;
      }

      private string KindToKeyword(TypeKind kind) {
         if (kind == TypeKind.Enum) return "enum";
         else if (kind == TypeKind.Struct) return "struct";
         else if (kind == TypeKind.Class) return "class";
         else throw new NotImplementedException($"Unhandled kind {kind}");
      }

      public void X(GeneratorExecutionContext context) {
         allUsingImports.Add("System");
         allUsingImports.Add("System.Numerics");
         allUsingImports.Add("Dargon.Commons");
         allUsingImports.Add("Dargon.Vox2");

         var sb = new StringBuilder();

         foreach (var (type, typeAttr) in entries) {
            HandleBeginNewTypeProcess();

            var typeIsStatic = type.IsStatic;
            var typeKindStr = KindToKeyword(type.TypeKind);

            if (!SymbolEqualityComparer.Default.Equals(typeAttr.AttributeClass, types.VoxTypeAttributeType)) {
               throw new Exception($"Expected {typeAttr.AttributeClass} to be {types.VoxTypeAttributeType}");
            }


            // nvm enums are ok, just can't use as autoserialized
            // if (type.TypeKind == TypeKind.Enum) {
            //    context.ReportDiagnostic(Diagnostic.Create(
            //       new DiagnosticDescriptor(
            //          VSGErrors.EnumsMustBeViaRedirectToType,
            //          VSGErrors.EnumsMustBeViaRedirectToTypeMessageTitle(type.Name),
            //          VSGErrors.EnumsMustBeViaRedirectToTypeMessageTitle(type.Name),
            //          VSGErrors.Category,
            //          DiagnosticSeverity.Error,
            //          isEnabledByDefault: true),
            //       typeAttr.ApplicationSyntaxReference.GetSyntax().GetLocation()));
            //    continue;
            // }

            int typeId = (int)typeAttr.ConstructorArguments[0].Value;
            int flags = 0;
            INamedTypeSymbol targetType = type;
            foreach (var narg in typeAttr.NamedArguments) {
               if (narg.Key == "RedirectToType") {
                  targetType = (INamedTypeSymbol)narg.Value.Value;
               } else if (narg.Key == "Flags") {
                  flags = (int)narg.Value.Value;
               }
            }
            
            var typeFullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var fullTargetTypeName = targetType.ToDisplayString();

            var genericArgsStr = targetType.IsGenericType
               ? $"<{string.Join(", ", targetType.TypeParameters.Select(x => x.ToDisplayString()))}>"
               : "";

            var genericArgsUnboundStr = targetType.IsGenericType
               ? $"<{string.Join(",", targetType.TypeParameters.Select(x => ""))}>"
               : "";

            var genericArgsConstraintsSb = new StringBuilder();
            var dependencySerializerTypeIdsSb = new StringBuilder();
            foreach (var tp in targetType.TypeParameters) {
               var constraintParts = new List<string>();
               if (tp.HasValueTypeConstraint) constraintParts.Add("struct");
               if (tp.HasNotNullConstraint) constraintParts.Add("notnull");
               if (tp.HasReferenceTypeConstraint) constraintParts.Add("class");
               if (tp.HasUnmanagedTypeConstraint) constraintParts.Add("unmanaged");

               foreach (var tpct in tp.ConstraintTypes) {
                  constraintParts.Add(tpct.ToDisplayString());
               }

               if (tp.HasConstructorConstraint) constraintParts.Add("new()");

               if (constraintParts.Count > 0) {
                  genericArgsConstraintsSb.AppendLine($"where {tp.Name} : {string.Join(", ", constraintParts)}");
               }

               var serializerName = GetDependencySerializerName(tp);
               dependencySerializerTypeIdsSb.Append($", {serializerName}.FullTypeId");
            }

            var genericArgsConstraints = genericArgsConstraintsSb.Length == 0 ? "" : (Environment.NewLine + genericArgsConstraintsSb.ToString().Trim());

            var classNesting = new List<INamedTypeSymbol> { targetType };
            while (classNesting[classNesting.Count - 1].ContainingType is { } ct) {
               classNesting.Add(ct);
            }

            var subclassHierarchy = new List<INamedTypeSymbol> { targetType };
            while (subclassHierarchy[subclassHierarchy.Count - 1].BaseType is { } bt) {
               subclassHierarchy.Add(bt);
            }

            var targetTypeKindStr = KindToKeyword(targetType.TypeKind);
            var targetIsStruct = targetType.TypeKind == TypeKind.Struct;
            var targetIsEnum = targetType.TypeKind == TypeKind.Enum;
            var targetEnumBackingTypeName = targetIsEnum ? ((INamedTypeSymbol)targetType).EnumUnderlyingType.Name : null;
            var stubFull = (flags & 1 /* VoxTypeFlags.StubFull */) != 0;
            var stubRaw = (flags & 2 /* VoxTypeFlags.StubRaw */) != 0;
            var targetIsUpdatable = (flags & 4 /* VoxTypeFlags.NonUpdatable */) == 0;
            var targetIsNoCodeGen = (flags & 16 /* VoxTypeFlags.NoCodeGen */) == 16;

            if (targetIsNoCodeGen) {
               sb.AppendLine($"/* NoCodeGen flag specified for {typeFullName} */");
               continue;
            }

            if (targetIsEnum) {
               // default for enums
               targetIsUpdatable = false;
            }

            var refIfTargetIsStruct = targetIsStruct ? "ref " : "";
            var refIfTargetIsUpdatable = targetIsUpdatable ? "ref " : "";
            var refIfTargetIsUpdatableStruct = targetIsStruct && targetIsUpdatable ? "ref " : "";

            var writeFullSb = new StringBuilder();
            var writeRawSb = new StringBuilder();
            var readFullSb = new StringBuilder();
            var readRawSb = new StringBuilder();
            var stubDefs = new StringBuilder();

            if (stubFull) {
               writeFullSb.AppendLine($"{typeFullName}.Stub_WriteFull_{targetType.Name}(writer, {refIfTargetIsUpdatable}self);");
               stubDefs.AppendLine($"public static partial void Stub_WriteFull_{targetType.Name}(VoxWriter writer, {refIfTargetIsUpdatableStruct}{targetType.Name} value);");

               if (targetIsUpdatable) {
                  readFullSb.AppendLine($"{typeFullName}.Stub_ReadFullIntoRef_{targetType.Name}(reader, {refIfTargetIsUpdatable}self);");
                  stubDefs.AppendLine($"public static partial void Stub_ReadFullIntoRef_{targetType.Name}(VoxReader reader, {refIfTargetIsUpdatableStruct}{targetType.Name} value);");
               } else {
                  readFullSb.AppendLine($"{typeFullName}.Stub_ReadFull_{targetType.Name}(reader);");
                  stubDefs.AppendLine($"public static partial {targetType.Name} Stub_ReadFull_{targetType.Name}(VoxReader reader);");
               }
            } else {
               writeFullSb.AppendLine($"{targetType.Name}Serializer{genericArgsStr}.GetInstance(writer.Context).WriteTypeIdBytes(writer); WriteRaw(writer, ref self);");
               if (targetIsUpdatable) {
                  readFullSb.AppendLine($"{targetType.Name}Serializer{genericArgsStr}.GetInstance(reader.Context).AssertReadTypeId(reader); ReadRawIntoRef(reader, ref self);");
               } else {
                  readFullSb.AppendLine($"{targetType.Name}Serializer{genericArgsStr}.GetInstance(reader.Context).AssertReadTypeId(reader); return ReadRaw(reader);");
               }
            }

            if (stubRaw) {
               // public void WriteRaw(VoxWriter writer, int val) => writer.InnerWriter.Write(val);
               // public int ReadRaw(VoxReader reader) => reader.InnerReader.ReadInt32();
               writeRawSb.AppendLine($"{typeFullName}.Stub_WriteRaw_{targetType.Name}(writer, {refIfTargetIsUpdatableStruct}self);");
               stubDefs.AppendLine($"public static partial void Stub_WriteRaw_{targetType.Name}(VoxWriter writer, {refIfTargetIsUpdatableStruct}{targetType.Name} value);");

               if (targetIsUpdatable) {
                  // always emit with ref. In the case of structs it's necessary for updates, and in the case of reference types
                  // it allows the reference to be updated to null.
                  readRawSb.AppendLine($"{typeFullName}.Stub_ReadRawIntoRef_{targetType.Name}(reader, ref self);");
                  stubDefs.AppendLine($"public static partial void Stub_ReadRawIntoRef_{targetType.Name}(VoxReader reader, ref {targetType.Name} value);");
               } else {
                  readRawSb.AppendLine($"return {typeFullName}.Stub_ReadRaw_{targetType.Name}(reader);");
                  stubDefs.AppendLine($"public static partial {targetType.Name} Stub_ReadRaw_{targetType.Name}(VoxReader reader);");
               }
            } else {
               if (targetIsEnum) {
                  targetEnumBackingTypeName.AssertIsNotNull();
                  readRawSb.AppendLine($@"
                                                                                                                                  {{
                                                                                                                                       /* this is an enum */
                                                                                                                                       return ({fullTargetTypeName})reader.ReadRaw{targetEnumBackingTypeName}();
                                                                                                                                  }}");
                  writeRawSb.AppendLine($@"
                                                                                                                                  {{
                                                                                                                                       /* this is an enum */
                                                                                                                                       writer.WriteRaw{targetEnumBackingTypeName}(({targetEnumBackingTypeName})self);
                                                                                                                                  }}");
               } else if (targetIsUpdatable) {
                  if (!targetIsStruct) {
                     readRawSb.AppendLine($"if (self == null) throw new ArgumentNullException(nameof({targetType.Name}{genericArgsStr}));");
                  }
               } else {
                  readRawSb.AppendLine($"var self = new {targetType.Name}{genericArgsStr}();");
               }

               // this gets auto-property fields too. In a future C# lang version they'll expose property backing
               // fields too for getters/setters. Hopefully this'll work for that.
               var allFieldOrPropertySymbols = new List<ISymbol>();
               for (var i = subclassHierarchy.Count - 1; i >= 0; i--) {
                  foreach (var m in subclassHierarchy[i].GetMembers()) {
                     if (m is IFieldSymbol fs) {
                        if (!fs.IsImplicitlyDeclared && !fs.IsConst) {
                           allFieldOrPropertySymbols.Add(fs);
                        }
                     } else if (m is IPropertySymbol ps) {
                        // indexer is technically a property
                        // only serialize props with getter/setter.
                        if (!ps.IsIndexer && ps.GetMethod != null && ps.SetMethod != null) {
                           allFieldOrPropertySymbols.Add(ps);
                        }
                     }
                  }
               }
               foreach (var member in allFieldOrPropertySymbols) {
                  if (member.IsStatic) continue;

                  var memberType = member is IFieldSymbol fs ? fs.Type : ((IPropertySymbol)member).Type;
                  var memberAttr = RoslynUtils.FindAnyAttributeOrDefault(member, types.AllVoxAnnotationTypes);

                  readRawSb.AppendLine($@"
                                                                                                                                  {{");
                  var r = EmitRead(readRawSb, "", "_voxvarname", memberType, memberAttr?.AttributeClass);
                  readRawSb.AppendLine($@"
                                                                                                                                     self.{member.Name} = {r};
                                                                                                                                  }}");

                  writeRawSb.AppendLine($@"
                                                                                                                                  {{");
                  EmitWrite(writeRawSb, "", "_voxvarname", $"self.{member.Name}", memberType, memberAttr?.AttributeClass);
                  writeRawSb.AppendLine($@"
                                                                                                                                  }}");
               }

               if (!targetIsUpdatable && !targetIsEnum) {
                  readRawSb.AppendLine($"return self;");
               }
            }

            var fullTypeIdExpr = "new[] { kTypeId }";
            if (dependencySerializerTypeIdsSb.Length != 0) {
               fullTypeIdExpr = $"Arrays.Concat({fullTypeIdExpr}{dependencySerializerTypeIdsSb})";
            }

            var typeContainerScopeStartSb = new StringBuilder();
            typeContainerScopeStartSb.Append("namespace ");
            typeContainerScopeStartSb.Append(targetType.ContainingNamespace.ToDisplayString());
            typeContainerScopeStartSb.Append(" {");
            
            var typeContainerScopeEndSb = new StringBuilder();
            typeContainerScopeEndSb.Append("}");

            var typeContainerQualifierSb = new StringBuilder();
            var typeContainerNamePrefixSb = new StringBuilder();

            for (var i = classNesting.Count - 1; i >= 1; i--) {
               var x = classNesting[i];
               typeContainerScopeStartSb.Append(" public ");
               typeContainerScopeStartSb.Append(x.IsStatic ? "static " : "");
               typeContainerScopeStartSb.Append("partial ");
               typeContainerScopeStartSb.Append(x.IsValueType ? "struct" : "class");
               typeContainerScopeStartSb.Append(" ");
               typeContainerScopeStartSb.Append(x.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat));
               typeContainerScopeStartSb.Append(" {");

               typeContainerScopeEndSb.Append(" }");
               
               typeContainerQualifierSb.Append(x.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat));
               typeContainerQualifierSb.Append(".");

               typeContainerNamePrefixSb.Append(x.Name);

            }

            var typeContainerScopeStart = typeContainerScopeStartSb.ToString();
            var typeContainerScopeEnd = typeContainerScopeEndSb.ToString();
            var typeContainerQualifier = typeContainerQualifierSb.ToString();
            var typeContainerNamePrefix = typeContainerNamePrefixSb.ToString();

            var extensionNamespace = classNesting[classNesting.Count - 1].ContainingNamespace.ToDisplayString();

            //                                                                                                       The below must work with strings, ints, vector3s, and hodgepodges.
            //                                                                                                       x.ReadFull/ReadRaw are optional.
            //                                                                                                       Within a serializer, write should invoke writer.WriteRaw{X}(x) if nonpolymorphic, else writer.WritePolymorphic(x)
            //                                                                                                       ... Cannot depend on interface calls on serializable, as builtins (e.g. int) don't implement the interface.
            //                                                                                                       Reader should invoke self.field = reader.ReadRaw{T}() if nonpolymorphic, else reader.ReadPolymorphic<T>()
            sb.AppendLine($@"
                                                                                                                        {typeContainerScopeStart}
                                                                                                                           /// <summary>Autogenerated</summary>
                                                                                                                           [VoxType(kTypeId, VanityRedirectFromType = typeof({type.Name}{genericArgsUnboundStr}))]
                                                                                                                           public sealed partial class {targetType.Name}Serializer{genericArgsStr} : IVoxSerializer<{targetType.Name}{genericArgsStr}>{genericArgsConstraints} {{
                                                                                                                              public const int kTypeId = {typeId};

                                                                                                                              private static {targetType.Name}Serializer{genericArgsStr} s_instance;
                                                                                                                              public static {targetType.Name}Serializer{genericArgsStr} GetInstance(VoxSerializerContainer vsc) => s_instance ??= new(vsc);
                                                                                                                              public static {targetType.Name}Serializer{genericArgsStr} GetInstance(VoxContext vox) => GetInstance(vox.SerializerContainer);

                                                                                                                              {dependencySerializerFieldDeclarationsSb}

                                                                                                                              public {targetType.Name}Serializer(VoxSerializerContainer vsc) {{
                                                                                                                                 {dependencySerializerFieldInitializersSb}

                                                                                                                                 SimpleTypeId = kTypeId;
                                                                                                                                 FullTypeId = {fullTypeIdExpr};
                                                                                                                                 FullTypeIdBytes = FullTypeId.ToVariableIntBytes();
                                                                                                                              }}

                                                                                                                              public int SimpleTypeId {{ get; }}
                                                                                                                              public int[] FullTypeId {{ get; }}
                                                                                                                              public byte[] FullTypeIdBytes {{ get; }}

                                                                                                                              public bool IsUpdatable => {(targetIsUpdatable ? "true" : "false")};

                                                                                                                              public void WriteTypeIdBytes(VoxWriter writer) => writer.WriteTypeIdBytes(FullTypeIdBytes);
                                                                                                                              public void AssertReadTypeId(VoxReader reader) => reader.AssertReadTypeIdBytes(FullTypeIdBytes);
                                                                                                                              public void WriteFull(VoxWriter writer, ref {targetType.Name}{genericArgsStr} self) {{ {writeFullSb} }}
                                                                                                                              public void WriteRaw(VoxWriter writer, ref {targetType.Name}{genericArgsStr} self) {{ {writeRawSb} }}
               ");

            if (targetIsUpdatable) {
               sb.AppendLine($@"
                                                                                                                              public {targetType.Name}{genericArgsStr} ReadFull(VoxReader reader) {{ {targetType.Name}{genericArgsStr} res = new(); ReadFullIntoRef(reader, ref res); return res; }}
                                                                                                                              public {targetType.Name}{genericArgsStr} ReadRaw(VoxReader reader) {{ {targetType.Name}{genericArgsStr} res = new(); ReadRawIntoRef(reader, ref res); return res; }}
                                                                                                                              public void ReadFullIntoRef(VoxReader reader, ref {targetType.Name}{genericArgsStr} self) {{ {readFullSb} }}
                                                                                                                              public void ReadRawIntoRef(VoxReader reader, ref {targetType.Name}{genericArgsStr} self) {{ {readRawSb} }}
                  ");
            } else {
               sb.AppendLine($@"
                                                                                                                              public {targetType.Name}{genericArgsStr} ReadFull(VoxReader reader) {{ {readFullSb} }}
                                                                                                                              public {targetType.Name}{genericArgsStr} ReadRaw(VoxReader reader) {{ {readRawSb} }}
                                                                                                                              public void ReadFullIntoRef(VoxReader reader, ref {targetType.Name}{genericArgsStr} self) => throw new InvalidOperationException({dq}Reading into {targetType.Name} ref is not supported.{dq});
                                                                                                                              public void ReadRawIntoRef(VoxReader reader, ref {targetType.Name}{genericArgsStr} self) => throw new InvalidOperationException({dq}Reading into {targetType.Name} ref is not supported.{dq});
                  ");
            }

            sb.AppendLine($@"
                                                                                                                              void IVoxSerializer.WriteRawObject(VoxWriter writer, object val) {{ {targetType.Name}{genericArgsStr} v = ({targetType.Name}{genericArgsStr})val; WriteRaw(writer, ref v); }}
                                                                                                                              object IVoxSerializer.ReadRawObject(VoxReader reader) => ReadRaw(reader);
                                                                                                                           }}
               ");

            if (ReferenceEquals(type, targetType) && !targetIsEnum) {
               sb.AppendLine($@"
                                                                                                                           /// <summary>Autogenerated</summary>
                                                                                                                           [VoxInternalsAutoSerializedTypeInfoAttribute(GenericSerializerTypeDefinition = typeof({targetType.Name}Serializer{genericArgsUnboundStr}))]
                                                                                                                           public partial {typeKindStr} {targetType.Name}{genericArgsStr} /* : IVoxCustomType<{fullTargetTypeName}>{genericArgsConstraints} */ {{
                                                                                                                              /* can't put more here because of enums */
                                                                                                                           }}");
            }
            sb.AppendLine($@"
                                                                                                                        {typeContainerScopeEnd}

                                                                                                                        namespace {extensionNamespace} {{

                                                                                                                           /// <summary>Autogenerated</summary>
                                                                                                                           public static class VoxGenerated_{targetType.Name}Statics {{
                                                                                                                              internal static {typeContainerQualifier}{targetType.Name}Serializer{genericArgsStr} GetSerializerInstance{genericArgsStr}{genericArgsConstraints}(VoxContext vox) => {typeContainerQualifier}{targetType.Name}Serializer{genericArgsStr}.GetInstance(vox.SerializerContainer);

                                                                                                                              public static void WriteFull{typeContainerNamePrefix}{targetType.Name}{genericArgsStr}{genericArgsConstraints}(this VoxWriter writer, {fullTargetTypeName} value) {{ var copy = value; GetSerializerInstance{genericArgsStr}(writer.Context).WriteFull(writer, ref value); }}
                                                                                                                              public static void WriteRaw{typeContainerNamePrefix}{targetType.Name}{genericArgsStr}{genericArgsConstraints}(this VoxWriter writer, {fullTargetTypeName} value) {{ var copy = value; GetSerializerInstance{genericArgsStr}(writer.Context).WriteRaw(writer, ref value); }}
                                                                                                                              public static {typeContainerQualifier}{targetType.Name}{genericArgsStr} ReadFull{typeContainerNamePrefix}{targetType.Name}{genericArgsStr}{genericArgsConstraints}(this VoxReader reader) => GetSerializerInstance{genericArgsStr}(reader.Context).ReadFull(reader);
                                                                                                                              public static {typeContainerQualifier}{targetType.Name}{genericArgsStr} ReadRaw{typeContainerNamePrefix}{targetType.Name}{genericArgsStr}{genericArgsConstraints}(this VoxReader reader) => GetSerializerInstance{genericArgsStr}(reader.Context).ReadRaw(reader);
            ");

            sb.AppendLine($@"
                                                                                                                              public static void WriteFullInto{genericArgsStr}{genericArgsConstraints}(this {typeContainerQualifier}{targetType.Name}{genericArgsStr} self, VoxWriter writer) {{ var copy = self; GetSerializerInstance{genericArgsStr}(writer.Context).WriteFull(writer, ref copy); }}
                                                                                                                              public static void WriteRawInto{genericArgsStr}{genericArgsConstraints}(this {typeContainerQualifier}{targetType.Name}{genericArgsStr} self, VoxWriter writer) {{ var copy = self; GetSerializerInstance{genericArgsStr}(writer.Context).WriteRaw(writer, ref copy); }}
            ");

            if (targetIsUpdatable) {
               var copyToSelfIfStruct = targetIsStruct ? " self = copy;" : "";
               sb.AppendLine($@"
                                                                                                                              public static void ReadFullFrom{genericArgsStr}{genericArgsConstraints}({refIfTargetIsStruct} this {typeContainerQualifier}{targetType.Name}{genericArgsStr} self, VoxReader reader) {{ var copy = self; GetSerializerInstance{genericArgsStr}(reader.Context).ReadFullIntoRef(reader, ref copy);{copyToSelfIfStruct} }}
                                                                                                                              public static void ReadRawFrom{genericArgsStr}{genericArgsConstraints}({refIfTargetIsStruct} this {typeContainerQualifier}{targetType.Name}{genericArgsStr} self, VoxReader reader) {{ var copy = self; GetSerializerInstance{genericArgsStr}(reader.Context).ReadRawIntoRef(reader, ref copy);{copyToSelfIfStruct} }}
               ");
            }

            sb.AppendLine($@"

                                                                                                                           }}
                                                                                                                        }}

                                                                                                                        // Stubs
                                                                                                                        namespace {type.ContainingNamespace.ToDisplayString()} {{
               ");

            if (stubDefs.Length > 0) {
               sb.AppendLine($@"
                                                                                                                           /// <summary>Autogenerated</summary>
                                                                                                                           public {(typeIsStatic ? "static" : "/* nonstatic */")} partial {typeKindStr} {type.Name} {{
                                                                                                                              { stubDefs}                                                               
                                                                                                                           }}");
            }

            sb.AppendLine($@"
                                                                                                                        }}");
         }

         var preambleSb = new StringBuilder();
         preambleSb.AppendLine($@"
                                                                                                                        // <auto-generated/>");
         foreach (var x in allUsingImports.OrderBy(x => x)) {
            preambleSb.AppendLine($@"
                                                                                                                        using {x};");
         }

         // Add the source code to the compilation
         var hintName = $"{Path.GetFileName(syntaxTree.FilePath)}.Vox.AutoGenerated.cs";
         context.AddSource(hintName, preambleSb.ToString() + sb.ToString());
      }

   /*
    * var _arr_count = reader.ReadRawInt32();
    * var _arr = new T[_arr_count];
    * for (var _arr_i = 0; _arr_i < _arr_count; _arr_i++) {
    *   var _arr_el_dict_count = reader.ReadRawInt32();
    *   var _arr_el_dict = new Dictionary<int, int[]>();
    *   for (var _arr_el_dict_i = 0; i < _arr_el_dict_count; _arr_el_dict_i++) {
    *     var _arr_el_dict_key = reader.ReadRawInt32();
    *     var _arr_el_dict_value_arr_count = reader.ReadRawInt32();
    *     var _arr_el_dict_value_arr = new int[_arr_el_dict_value_arr_count];
    *     for (var _arr_el_dict_value_arr_i = 0; _arr_el_dict_value_arr_i < _arr_el_dict_value_arr_count; _arr_el_dict_value_arr_i++) {
    *       _arr_el_dict_value_arr[_arr_el_dict_value_arr_i] = reader.ReadRawInt32();
    *     }
    *     _arr_el_dict.add(_arr_el_dict_key, _arr_el_dict_value_arr);
    *   }
    *   _arr[_arr_i] = _arr_el_dict;
    * }
    * field = _arr;
    *
    * --
    *
    * writer.WriteRawInt32(x.Length);
    * foreach (var _arr_el in x.
    */
   string EmitRead(StringBuilder sb, string ind, string baseName, ITypeSymbol t, ITypeSymbol polymorphismAttribute) {
      var isPolymorphic = polymorphismAttribute?.Name.StartsWith("P") ?? false;

      var subpolyAttrs = (polymorphismAttribute as INamedTypeSymbol)?.TypeArguments ?? ImmutableArray<ITypeSymbol>.Empty;
      ITypeSymbol subpolyattr0 = subpolyAttrs.FirstOrDefault() ??
                                 (polymorphismAttribute as IArrayTypeSymbol)?.ElementType;
      ITypeSymbol subpolyattr1 = subpolyAttrs.Skip(1).FirstOrDefault();

      var classification = ClassifyType(t, out var targ0, out var targ1);
      if (classification == TypeClassification.Regular) {
         if (isPolymorphic) {
            return $"reader.ReadPolymorphic<{t.ToDisplayString()}>()";
         } else if (t is ITypeParameterSymbol || (t is INamedTypeSymbol nts && nts.IsGenericType)) {
            var serializerName = GetDependencySerializerName(t);
            return $"{serializerName}.ReadRaw(reader);";
         } else {
            if (t.Name == "Object") Debugger.Break();
            allUsingImports.Add(t.ContainingNamespace.ToDisplayString());
            return $"reader.ReadRaw{t.Name}()";
         }
      } else if (classification == TypeClassification.Array) {
         // a field of type Animal can be assigned Dog (polymorphic)
         // whereas a field of type int[] cannot be assigned anything but an int[] or null.
         // to vox, this is considered nonpolymorphic (we don't need to explicitly serialize the array's type)
         isPolymorphic.AssertEquals(false);

         baseName += "_arr";
         sb.AppendLine($"{ind}var {baseName}_count = reader.ReadRawInt32();");
         sb.AppendLine($"{ind}var {baseName} = {baseName}_count == -1 ? null : {BuildArrayNewString(targ0, $"{baseName}_count")};");
         sb.AppendLine($"{ind}for (var {baseName}_i = 0; {baseName}_i < {baseName}_count; {baseName}_i++) {{");
         {
            var elres = EmitRead(sb, ind + "   ", $"{baseName}_el", targ0, subpolyattr0);
            sb.AppendLine($"{ind}   {baseName}[{baseName}_i] = {elres};");
         }
         sb.AppendLine($"{ind}}}");
         return baseName;
      } else if (classification == TypeClassification.Sequence) {
         // As with the array field case, we don't attempt to transmit the type of serialized collections;
         // rather, we transmit the contained data and on deserialize create a collection instance that
         // matches the field type (which might be concrete).
         isPolymorphic.AssertEquals(false);

         baseName += "_arr";
         sb.AppendLine($"{ind}var {baseName}_count = reader.ReadRawInt32();");
         var tds = t.ToDisplayString(NullableFlowState.NotNull);
         var tdsCtorArgs = $"{baseName}_count";
         sb.AppendLine($"{ind}var {baseName} = {baseName}_count == -1 ? null : new {tds}({tdsCtorArgs});");
         sb.AppendLine($"{ind}for (var {baseName}_i = 0; {baseName}_i < {baseName}_count; {baseName}_i++) {{");
         {
            var elres = EmitRead(sb, ind + "   ", $"{baseName}_el", targ0, subpolyattr0);
            sb.AppendLine($"{ind}   {baseName}.Add({elres});");
         }
         sb.AppendLine($"{ind}}}");
         return baseName;
      } else if (classification == TypeClassification.DictLike) {
         baseName += "_dict";
         sb.AppendLine($"{ind}var {baseName}_count = reader.ReadRawInt32();");

         var tds = t.ToDisplayString(NullableFlowState.NotNull);
         var isConcurrentDictionary = tds.Contains("ConcurrentDictionary");
         var tdsCtorArgs = isConcurrentDictionary ? "" : $"{baseName}_count";
         var addFunctionName = isConcurrentDictionary ? "TryAdd" : "Add";
         sb.AppendLine($"{ind}var {baseName} = {baseName}_count == -1 ? null : new {tds}({tdsCtorArgs});");
         sb.AppendLine($"{ind}for (var {baseName}_i = 0; {baseName}_i < {baseName}_count; {baseName}_i++) {{");
         {
            var keyres = EmitRead(sb, ind + "   ", $"{baseName}_key", targ0, subpolyattr0);
            sb.AppendLine($"{ind}   var {baseName}_key = {keyres};");

            var valres = EmitRead(sb, ind + "   ", $"{baseName}_val", targ1, subpolyattr1);
            sb.AppendLine($"{ind}   var {baseName}_val = {valres};");
            sb.AppendLine($"{ind}   {baseName}.{addFunctionName}({baseName}_key, {baseName}_val);");
         }
         sb.AppendLine($"{ind}}}");
         return baseName;
      } else if (classification == TypeClassification.TupleLike) {
         var tNts = (INamedTypeSymbol)t;
         baseName += "_tuple";

         var tupleItems = new List<string>();
         for (var i = 0; i < tNts.TupleElements.Length; i++) {
            var tupleElement = tNts.TupleElements[i];
            var elementPolymorphismAttr = subpolyAttrs.Length == 0 ? null : subpolyAttrs[i];
            var elres = EmitRead(sb, ind + "   ", $"{baseName}_item_{i}", tupleElement.Type, elementPolymorphismAttr);
            var elementName = tupleElement.IsExplicitlyNamedTupleElement ? tupleElement.Name : $"Item{i + 1}";
            var tupleVarName = $"{baseName}_item_{i}_res";
            sb.AppendLine($"{ind}var {tupleVarName} = {elres};");
            tupleItems.Add(elementName + ": " + tupleVarName);
         }

         var tupleBody = string.Join(", ", tupleItems);
         sb.AppendLine($"{ind}var {baseName} = ({tupleBody});");
         return baseName;
      } else if (classification == TypeClassification.Enum) {
         var underlyingType = ((INamedTypeSymbol)t).EnumUnderlyingType.Name; // e.g. Int8, Int16, UInt16, Int64
         return $"({t.ToDisplayString()})reader.ReadRaw{underlyingType}();";
      }

      throw new NotImplementedException();
   }

   void EmitWrite(StringBuilder sb, string ind, string baseName, string sourceExpression, ITypeSymbol t, ITypeSymbol polymorphismAttribute) {
      var isPolymorphic = polymorphismAttribute?.Name.StartsWith("P") ?? false;

      var subpolyAttrs = (polymorphismAttribute as INamedTypeSymbol)?.TypeArguments ?? ImmutableArray<ITypeSymbol>.Empty;
      ITypeSymbol subpolyattr0 = subpolyAttrs.FirstOrDefault() ??
                                 (polymorphismAttribute as IArrayTypeSymbol)?.ElementType;
      ITypeSymbol subpolyattr1 = subpolyAttrs.Skip(1).FirstOrDefault();

      var classification = ClassifyType(t, out var targ0, out var targ1);
      if (classification == TypeClassification.Regular) {
         if (isPolymorphic) {
            sb.AppendLine($"{ind}writer.WritePolymorphic<{t.ToDisplayString()}>({sourceExpression});");
         } else if (t is ITypeParameterSymbol || (t is INamedTypeSymbol nts && nts.IsGenericType)) {
            var serializerName = GetDependencySerializerName(t);
            baseName += "_copy";
            sb.AppendLine($"{ind}var {baseName} = {sourceExpression};");
            sb.AppendLine($"{ind}{serializerName}.WriteRaw(writer, ref {baseName});");
         } else {
            allUsingImports.Add(t.ContainingNamespace.ToDisplayString());
            sb.AppendLine($"{ind}writer.WriteRaw{t.Name}({sourceExpression});");
         }
      } else if (classification == TypeClassification.Array) {
         // a field of type Animal can be assigned Dog (polymorphic)
         // whereas a field of type int[] cannot be assigned anything but an int[] or null.
         // to vox, this is considered nonpolymorphic (we don't need to explicitly serialize the array's type)
         isPolymorphic.AssertEquals(false);

         baseName += "_arr";
         sb.AppendLine($"{ind}var {baseName} = {sourceExpression};");
         sb.AppendLine($"{ind}if ({baseName} == null) {{");
         sb.AppendLine($"{ind}   writer.WriteRawInt32((int)-1);");
         sb.AppendLine($"{ind}}} else {{");
         sb.AppendLine($"{ind}   writer.WriteRawInt32({baseName}.Length);");
         sb.AppendLine($"{ind}   for (var {baseName}_i = 0; {baseName}_i < {baseName}.Length; {baseName}_i++) {{");
         {
            EmitWrite(sb, ind + "      ", $"{baseName}_el", $"{baseName}[{baseName}_i]", targ0, subpolyattr0);
         }
         sb.AppendLine($"{ind}   }}");
         sb.AppendLine($"{ind}}}");
      } else if (classification == TypeClassification.Sequence) {
         // We don't attempt to transmit the type of serialized collections; rather, we transmit the contained
         // data and on deserialize create a collection instance that matches the field type (which might be concrete).
         isPolymorphic.AssertEquals(false);

         baseName += "_arr";
         sb.AppendLine($"{ind}var {baseName} = {sourceExpression};");
         sb.AppendLine($"{ind}if ({baseName} == null) {{");
         sb.AppendLine($"{ind}   writer.WriteRawInt32((int)-1);");
         sb.AppendLine($"{ind}}} else {{");
         sb.AppendLine($"{ind}   writer.WriteRawInt32({baseName}.Count);");
         sb.AppendLine($"{ind}   foreach (var {baseName}_el in {baseName}) {{");
         {
            EmitWrite(sb, ind + "      ", $"{baseName}_el", $"{baseName}_el", targ0, subpolyattr0);
         }
         sb.AppendLine($"{ind}   }}");
         sb.AppendLine($"{ind}}}");
      } else if (classification == TypeClassification.DictLike) {
         baseName += "_dict";
         sb.AppendLine($"{ind}var {baseName} = {sourceExpression};");
         sb.AppendLine($"{ind}if ({baseName} == null) {{");
         sb.AppendLine($"{ind}   writer.WriteRawInt32((int)-1);");
         sb.AppendLine($"{ind}}} else {{");
         sb.AppendLine($"{ind}   writer.WriteRawInt32({baseName}.Count);");
         sb.AppendLine($"{ind}   foreach (var {baseName}_kvp in {baseName}) {{");
         {
            EmitWrite(sb, ind + "      ", $"{baseName}_key", $"{baseName}_kvp.Key", targ0, subpolyattr0);
            EmitWrite(sb, ind + "      ", $"{baseName}_value", $"{baseName}_kvp.Value", targ1, subpolyattr1);
         }
         sb.AppendLine($"{ind}   }}");
         sb.AppendLine($"{ind}}}");
      } else if (classification == TypeClassification.TupleLike) {
         var tNts = (INamedTypeSymbol)t;
         baseName += "_tuple";

         sb.AppendLine($"{ind}var {baseName} = {sourceExpression};");

         for (var i = 0; i < tNts.TupleElements.Length; i++) {
            var tupleElement = tNts.TupleElements[i];
            var elementPolymorphismAttr = subpolyAttrs.Length == 0 ? null : subpolyAttrs[i];
            var elementName = tupleElement.IsExplicitlyNamedTupleElement ? tupleElement.Name : $"Item{i + 1}";
            EmitWrite(sb, ind + "   ", $"{baseName}_item_{i}", $"{baseName}.{elementName}", tupleElement.Type, elementPolymorphismAttr);
         }
      } else if (classification == TypeClassification.Enum) {
         var underlyingType = ((INamedTypeSymbol)t).EnumUnderlyingType.Name; // e.g. Int8, Int16, UInt16, Int64
         sb.AppendLine($"{ind}writer.WriteRaw{underlyingType}(({underlyingType})({sourceExpression}));");
      } else {
         throw new NotImplementedException();
      }
   }


   public enum TypeClassification {
         Regular,
         Array,
         Sequence,
         DictLike,
         TupleLike,
         Enum,
      }

      private TypeClassification ClassifyType(ITypeSymbol t, out ITypeSymbol targ0, out ITypeSymbol targ1) {
         if (t is IArrayTypeSymbol ats) {
            targ0 = ats.ElementType;
            targ1 = null;
            return TypeClassification.Array;
         }

         if (t.TypeKind == TypeKind.Enum) {
            targ0 = targ1 = null;
            return TypeClassification.Enum;
         }

         if (t.Name == "String") {
            targ0 = targ1 = null;
            return TypeClassification.Regular;
         }

         if (t.IsTupleType) {
            targ0 = targ1 = null;
            return TypeClassification.TupleLike;
         }

         targ0 = targ1 = null;

         foreach (var iface in t.AllInterfaces) {
            if (iface.Name.IndexOf("Dictionary", StringComparison.OrdinalIgnoreCase) >= 0 && iface.IsGenericType) {
               targ0 = iface.TypeArguments[0];
               targ1 = iface.TypeArguments[1];
               return TypeClassification.DictLike;
            }

            if (iface.Name.IndexOf("IEnumerable", StringComparison.OrdinalIgnoreCase) >= 0 && iface.IsGenericType) {
               targ0 = iface.TypeArguments[0];
            }
         }

         return targ0 != null ? TypeClassification.Sequence : TypeClassification.Regular;
      }

      private string BuildArrayNewString(ITypeSymbol elType, string indexExpr) {
         var nestedArrayDepth = 0;
         while (elType is IArrayTypeSymbol arts) {
            nestedArrayDepth++;
            elType = arts.ElementType;
         }

         var sb = new StringBuilder();
         sb.Append("new ");
         sb.Append(elType.ToDisplayString(NullableFlowState.NotNull));
         sb.Append($"[{indexExpr}]");
         for (var i = 0; i < nestedArrayDepth; i++) {
            sb.Append($"[]");
         }
         return sb.ToString();
      }
   }
}