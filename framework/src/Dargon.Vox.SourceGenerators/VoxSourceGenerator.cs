using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Dargon.Vox.SourceGenerators {
   [Generator]
   public class VoxSourceGenerator : ISourceGenerator {
      public void Initialize(GeneratorInitializationContext context) {
         if (!Debugger.IsAttached) {
            //Debugger.Launch();
         }  
      }

      public void Execute(GeneratorExecutionContext context) {
         try {
            ExecuteInternal(context);
         } catch (Exception e) {
            // See 
            context.ReportDiagnostic(Diagnostic.Create(
               new DiagnosticDescriptor(
                  "SI0000",
                  $"An exception was thrown by {nameof(VoxSourceGenerator)}",
                  $"An exception was thrown by {nameof(VoxSourceGenerator)}: '{e}'",
                  "StrongInject",
                  DiagnosticSeverity.Error,
                  isEnabledByDefault: true),
               Location.None,
               e.ToString()));
         }
      }

      public class KnownTypes {
         public KnownTypes(GeneratorExecutionContext context) {
            AllNamedTypes = EnumerateNamedTypeSymbols(context.Compilation.GlobalNamespace).ToList();
            VoxInternalBaseDummyType = AllNamedTypes.First(t => t.Name == "VoxInternalBaseDummyType");
            VoxInternalBaseAttribute = AllNamedTypes.First(t => t.Name == "VoxInternalBaseAttribute");
            AllVoxTypeAttributes = FilterTypeDescendentsAndSelf(AllNamedTypes, VoxInternalBaseAttribute);
            AllVoxDummyTypes = FilterTypeDescendentsAndSelf(AllNamedTypes, VoxInternalBaseDummyType);
            AllVoxAnnotationTypes = AllVoxTypeAttributes.Concat(AllVoxDummyTypes).ToList();
            VoxTypeAttributeType = AllNamedTypes.First(t => t.Name == "VoxTypeAttribute");

            SyntaxTreeToTypeAndVoxTypeAttribute =
               AllNamedTypes.Where(t => t.TypeKind == TypeKind.Class || t.TypeKind == TypeKind.Struct)
                            .SelectPairValue(t => RoslynUtils.FindAnyAttributeOrDefault(t, AllVoxTypeAttributes))
                            .Where(kvp => kvp.Value != null)
                            .Where(kvp => kvp.Value.ApplicationSyntaxReference != null) // null if from dependency project
                            .Where(kvp => context.Compilation.ContainsSyntaxTree(kvp.Value.ApplicationSyntaxReference.SyntaxTree)) // don't include if out of compilation (e.g. generated by another compilation's source generator)
                            .GroupBy(kvp => kvp.Value.ApplicationSyntaxReference.SyntaxTree.AssertIsNotNull())
                            .Select(g => new KeyValuePair<SyntaxTree, List<KeyValuePair<INamedTypeSymbol, AttributeData>>>(g.Key, g.ToList()))
                            .ToList();
         }

         public List<INamedTypeSymbol> AllNamedTypes { get; }
         public INamedTypeSymbol VoxInternalBaseDummyType { get; }
         public INamedTypeSymbol VoxInternalBaseAttribute { get; }
         public List<INamedTypeSymbol> AllVoxTypeAttributes { get; }
         public List<INamedTypeSymbol> AllVoxDummyTypes { get; }
         public List<INamedTypeSymbol> AllVoxAnnotationTypes { get; }
         public INamedTypeSymbol VoxTypeAttributeType { get; }
         public List<KeyValuePair<SyntaxTree, List<KeyValuePair<INamedTypeSymbol, AttributeData>>>> SyntaxTreeToTypeAndVoxTypeAttribute { get; }

         private List<INamedTypeSymbol> EnumerateNamedTypeSymbols(INamespaceOrTypeSymbol searchStart) {
            var res = new List<INamedTypeSymbol>();
            void Inner(INamespaceOrTypeSymbol cur) {
               if (cur is INamedTypeSymbol nts) {
                  res.Add(nts);

                  foreach (var x in nts.GetTypeMembers()) {
                     Inner(x);
                  }
               }

               if (cur is INamespaceSymbol ns) {
                  foreach (var x in ns.GetNamespaceMembers()) {
                     Inner(x);
                  }
                  foreach (var x in ns.GetTypeMembers()) {
                     Inner(x);
                  }
               }
            }

            Inner(searchStart);
            return res;
         }

         private List<INamedTypeSymbol> FilterTypeDescendentsAndSelf(List<INamedTypeSymbol> haystack, INamedTypeSymbol baseType) {
            baseType.TypeKind.AssertEquals(TypeKind.Class);

            var res = new List<INamedTypeSymbol> { baseType };
            foreach (var t in haystack) {
               for (var current = t; current != null; current = current.BaseType) {
                  if (SymbolEqualityComparer.Default.Equals(current.BaseType, baseType)) {
                     res.Add(t);
                  }
               }
            }

            return res;
         }
      }

      private void ExecuteInternal(GeneratorExecutionContext context) {
         var types = new KnownTypes(context);

         foreach (var (syntaxTree, entries) in types.SyntaxTreeToTypeAndVoxTypeAttribute) {
            new VoxTypePartialSourceEmitter(types, syntaxTree, entries).X(context);
         }
      }
   }

   public static class RoslynUtils {
      public static AttributeData FindAnyAttributeOrDefault(ISymbol t, List<INamedTypeSymbol> searchCandidates) {
         foreach (var attr in t.GetAttributes()) {
            var attrc = attr.AttributeClass;
            if (attrc.IsGenericType) {
               attrc = attrc.OriginalDefinition;
            }
            foreach (var candidate in searchCandidates) {
               if (SymbolEqualityComparer.Default.Equals(attrc, candidate)) {
                  return attr;
               }
            }
         }

         return null;
      }
   }

   public static class Extensions {
      public static T AssertEquals<T>(this T a, T b) {
         if (!a.Equals(b)) throw new Exception($"{a} != {b}");
         return a;
      }
      public static T AssertIsNotNull<T>(this T a) where T : class {
         if (a == null) throw new Exception($"Expected non-null instance of `{typeof(T).FullName}`.");
         return a;
      }

      public static IEnumerable<KeyValuePair<T, TProj>> SelectPairValue<T, TProj>(this IEnumerable<T> e, Func<T, TProj> proj) => e.Select(x => new KeyValuePair<T, TProj>(x, proj(x)));
      public static void Deconstruct<TKey, TValue>(this KeyValuePair<TKey, TValue> source, out TKey Key, out TValue Value) => (Key, Value) = (source.Key, source.Value);
      public static void Deconstruct<TKey, TValue>(this IGrouping<TKey, TValue> source, out TKey Key, out IEnumerable<TValue> Value) => (Key, Value) = (source.Key, source);
   }

   public class VoxTypePartialSourceEmitter {
      private const char dq = '"';

      private readonly VoxSourceGenerator.KnownTypes types;
      private readonly SyntaxTree syntaxTree;
      private readonly List<KeyValuePair<INamedTypeSymbol, AttributeData>> entries;

      public VoxTypePartialSourceEmitter(VoxSourceGenerator.KnownTypes types, SyntaxTree syntaxTree, List<KeyValuePair<INamedTypeSymbol, AttributeData>> entries) {
         this.types = types;
         this.syntaxTree = syntaxTree;
         this.entries = entries;
      }

      private readonly HashSet<string> allUsingImports = new HashSet<string>();

      private readonly HashSet<string> knownDependencySerializerNames = new HashSet<string>();
      private readonly StringBuilder dependencySerializerFieldDeclarationsSb = new StringBuilder();
      private readonly StringBuilder dependencySerializerFieldInitializersSb = new StringBuilder();

      private void HandleBeginNewTypeProcess() {
         knownDependencySerializerNames.Clear();
         dependencySerializerFieldDeclarationsSb.Clear();
         dependencySerializerFieldInitializersSb.Clear();
      }

      private string GetDependencySerializerName(ITypeSymbol ts) {
         var ds = ts.ToDisplayString();
         var name = ds.Replace(":", "_").Replace(".", "_").Replace("<", "1337").Replace(">", "1338").Replace(",", "_");
         var serializerName = $"_dep_{name}";
         
         if (knownDependencySerializerNames.Add(serializerName)) {
            dependencySerializerFieldDeclarationsSb.AppendLine($"private IVoxSerializer<{ds}> {serializerName};");
            dependencySerializerFieldInitializersSb.AppendLine($"{serializerName} = vsc.GetSerializerForType<{ds}>();");
         }

         return serializerName;
      }

      public void X(GeneratorExecutionContext context) {
         allUsingImports.Add("System");
         allUsingImports.Add("System.Numerics");
         allUsingImports.Add("Dargon.Commons");
         allUsingImports.Add("Dargon.Vox2");

         var sb = new StringBuilder();

         foreach (var (type, typeAttr) in entries) {
            HandleBeginNewTypeProcess();

            var typeIsStatic = type.IsStatic;
            var typeIsStruct = type.TypeKind == TypeKind.Struct;
            var typeKindStr = typeIsStruct ? "struct" : "class";
            var typeFullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            if (!SymbolEqualityComparer.Default.Equals(typeAttr.AttributeClass, types.VoxTypeAttributeType)) {
               throw new Exception($"Expected {typeAttr.AttributeClass} to be {types.VoxTypeAttributeType}");
            }

            int typeId = (int)typeAttr.ConstructorArguments[0].Value;
            int flags = 0;
            INamedTypeSymbol targetType = type;
            foreach (var narg in typeAttr.NamedArguments) {
               if (narg.Key == "RedirectToType") {
                  targetType = (INamedTypeSymbol)narg.Value.Value;
               } else if (narg.Key == "Flags") {
                  flags = (int)narg.Value.Value;
               }
            }

            var fullTargetTypeName = targetType.ToDisplayString();

            var genericArgsStr = type.IsGenericType
               ? $"<{string.Join(", ", type.TypeParameters.Select(x => x.ToDisplayString()))}>"
               : "";

            var genericArgsUnboundStr = type.IsGenericType
               ? $"<{string.Join(",", type.TypeParameters.Select(x => ""))}>"
               : "";

            var genericArgsConstraintsSb = new StringBuilder();
            var dependencySerializerTypeIdsSb = new StringBuilder();
            foreach (var tp in type.TypeParameters) {
               var constraintParts = new List<string>();
               if (tp.HasValueTypeConstraint) constraintParts.Add("struct");
               if (tp.HasNotNullConstraint) constraintParts.Add("notnull");
               if (tp.HasReferenceTypeConstraint) constraintParts.Add("class");
               if (tp.HasUnmanagedTypeConstraint) constraintParts.Add("unmanaged");

               foreach (var tpct in tp.ConstraintTypes) {
                  constraintParts.Add(tpct.ToDisplayString());
               }

               if (tp.HasConstructorConstraint) constraintParts.Add("new()");

               if (constraintParts.Count > 0) {
                  genericArgsConstraintsSb.AppendLine($"where {tp.Name} : {string.Join(", ", constraintParts)}");
               }

               var serializerName = GetDependencySerializerName(tp);
               dependencySerializerTypeIdsSb.Append($", {serializerName}.FullTypeId");
            }

            var genericArgsConstraints = genericArgsConstraintsSb.Length == 0 ? "" : (Environment.NewLine + genericArgsConstraintsSb.ToString().Trim());

            var targetIsStruct = targetType.TypeKind == TypeKind.Struct;
            var stubFull = (flags & 1 /* VoxTypeFlags.StubFull */) != 0;
            var stubRaw = (flags & 2 /* VoxTypeFlags.StubRaw */) != 0;
            var targetIsUpdatable = (flags & 4 /* VoxTypeFlags.NonUpdatable */) == 0;
            var targetIsNoCodeGen = (flags & 16 /* VoxTypeFlags.NoCodeGen */) == 16;

            if (targetIsNoCodeGen) {
               sb.AppendLine($"/* NoCodeGen flag specified for {typeFullName} */");
               continue;
            }

            var refIfTargetIsStruct = targetIsStruct ? "ref " : "";
            var refIfTargetIsUpdatable = targetIsUpdatable ? "ref " : "";
            var refIfTargetIsUpdatableStruct = targetIsStruct && targetIsUpdatable ? "ref " : "";

            var writeFullSb = new StringBuilder();
            var writeRawSb = new StringBuilder();
            var readFullSb = new StringBuilder();
            var readRawSb = new StringBuilder();
            var stubDefs = new StringBuilder();

            if (stubFull) {
               writeFullSb.AppendLine($"{typeFullName}.Stub_WriteFull_{targetType.Name}(writer, {refIfTargetIsUpdatable}self);");
               stubDefs.AppendLine($"public static partial void Stub_WriteFull_{targetType.Name}(VoxWriter writer, {refIfTargetIsUpdatableStruct}{targetType.Name} value);");

               if (targetIsUpdatable) {
                  readFullSb.AppendLine($"{typeFullName}.Stub_ReadFullIntoRef_{targetType.Name}(reader, {refIfTargetIsUpdatable}self);");
                  stubDefs.AppendLine($"public static partial void Stub_ReadFullIntoRef_{targetType.Name}(VoxReader reader, {refIfTargetIsUpdatableStruct}{targetType.Name} value);");
               } else {
                  readFullSb.AppendLine($"{typeFullName}.Stub_ReadFull_{targetType.Name}(reader);");
                  stubDefs.AppendLine($"public static partial {targetType.Name} Stub_ReadFull_{targetType.Name}(VoxReader reader);");
               }
            } else {
               writeFullSb.AppendLine($"{targetType.Name}Serializer{genericArgsStr}.GetInstance(writer.Context).WriteTypeIdBytes(writer); WriteRaw(writer, ref self);");
               if (targetIsUpdatable) {
                  readFullSb.AppendLine($"{targetType.Name}Serializer{genericArgsStr}.GetInstance(reader.Context).AssertReadTypeId(reader); ReadRawIntoRef(reader, ref self);");
               } else {
                  readFullSb.AppendLine($"{targetType.Name}Serializer{genericArgsStr}.GetInstance(reader.Context).AssertReadTypeId(reader); return ReadRaw(reader);");
               }
            }

            if (stubRaw) {
               // public void WriteRaw(VoxWriter writer, int val) => writer.InnerWriter.Write(val);
               // public int ReadRaw(VoxReader reader) => reader.InnerReader.ReadInt32();
               writeRawSb.AppendLine($"{typeFullName}.Stub_WriteRaw_{targetType.Name}(writer, {refIfTargetIsUpdatableStruct}self);");
               stubDefs.AppendLine($"public static partial void Stub_WriteRaw_{targetType.Name}(VoxWriter writer, {refIfTargetIsUpdatableStruct}{targetType.Name} value);");

               if (targetIsUpdatable) {
                  // always emit with ref. In the case of structs it's necessary for updates, and in the case of reference types
                  // it allows the reference to be updated to null.
                  readRawSb.AppendLine($"{typeFullName}.Stub_ReadRawIntoRef_{targetType.Name}(reader, ref self);");
                  stubDefs.AppendLine($"public static partial void Stub_ReadRawIntoRef_{targetType.Name}(VoxReader reader, ref {targetType.Name} value);");
               } else {
                  readRawSb.AppendLine($"return {typeFullName}.Stub_ReadRaw_{targetType.Name}(reader);");
                  stubDefs.AppendLine($"public static partial {targetType.Name} Stub_ReadRaw_{targetType.Name}(VoxReader reader);");
               }
            } else {
               if (targetIsUpdatable) {
                  if (!targetIsStruct) {
                     readRawSb.AppendLine($"if (self == null) throw new ArgumentNullException(nameof({targetType.Name}{genericArgsStr}));");
                  }
               } else {
                  readRawSb.AppendLine($"var self = new {targetType.Name}();");
               }

               // this gets auto-property fields too. In a future C# lang version they'll expose property backing
               // fields too for getters/setters. Hopefully this'll work for that.
               var fields = targetType.GetMembers().OfType<IFieldSymbol>();
               foreach (var field in fields) {
                  if (field.IsConst) continue;
                  if (field.IsStatic) continue;

                  var member = field.AssociatedSymbol ?? field;
                  var memberType = member is IFieldSymbol fs ? fs.Type : ((IPropertySymbol)member).Type;
                  var memberAttr = RoslynUtils.FindAnyAttributeOrDefault(member, types.AllVoxAnnotationTypes);

                  readRawSb.AppendLine($@"
                                                                                                                                  {{");
                  var r = EmitRead(readRawSb, "", "_voxvarname", memberType, memberAttr?.AttributeClass);
                  readRawSb.AppendLine($@"
                                                                                                                                     self.{member.Name} = {r};
                                                                                                                                  }}");

                  writeRawSb.AppendLine($@"
                                                                                                                                  {{");
                  EmitWrite(writeRawSb, "", "_voxvarname", $"self.{member.Name}", memberType, memberAttr?.AttributeClass);
                  writeRawSb.AppendLine($@"
                                                                                                                                  }}");
               }

               if (!targetIsUpdatable) {
                  readRawSb.AppendLine($"return self;");
               }
            }

            var fullTypeIdExpr = "new[] { kTypeId }";
            if (dependencySerializerTypeIdsSb.Length != 0) {
               fullTypeIdExpr = $"Arrays.Concat({fullTypeIdExpr}{dependencySerializerTypeIdsSb})";
            }

            //                                                                                                       The below must work with strings, ints, vector3s, and hodgepodges.
            //                                                                                                       x.ReadFull/ReadRaw are optional.
            //                                                                                                       Within a serializer, write should invoke writer.WriteRaw{X}(x) if nonpolymorphic, else writer.WritePolymorphic(x)
            //                                                                                                       ... Cannot depend on interface calls on serializable, as builtins (e.g. int) don't implement the interface.
            //                                                                                                       Reader should invoke self.field = reader.ReadRaw{T}() if nonpolymorphic, else reader.ReadPolymorphic<T>()
            sb.AppendLine($@"
                                                                                                                        namespace {targetType.ContainingNamespace.ToDisplayString()} {{
                                                                                                                           /// <summary>Autogenerated</summary>
                                                                                                                           [VoxType(kTypeId, VanityRedirectFromType = typeof({type.Name}{genericArgsUnboundStr}))]
                                                                                                                           public sealed partial class {targetType.Name}Serializer{genericArgsStr} : IVoxSerializer<{targetType.Name}{genericArgsStr}>{genericArgsConstraints} {{
                                                                                                                              public const int kTypeId = {typeId};

                                                                                                                              private static {targetType.Name}Serializer{genericArgsStr} s_instance;
                                                                                                                              public static {targetType.Name}Serializer{genericArgsStr} GetInstance(VoxSerializerContainer vsc) => s_instance ??= new(vsc);
                                                                                                                              public static {targetType.Name}Serializer{genericArgsStr} GetInstance(VoxContext vox) => GetInstance(vox.SerializerContainer);

                                                                                                                              {dependencySerializerFieldDeclarationsSb}

                                                                                                                              public {targetType.Name}Serializer(VoxSerializerContainer vsc) {{
                                                                                                                                 {dependencySerializerFieldInitializersSb}

                                                                                                                                 SimpleTypeId = kTypeId;
                                                                                                                                 FullTypeId = {fullTypeIdExpr};
                                                                                                                                 FullTypeIdBytes = FullTypeId.ToVariableIntBytes();
                                                                                                                              }}

                                                                                                                              public int SimpleTypeId {{ get; }}
                                                                                                                              public int[] FullTypeId {{ get; }}
                                                                                                                              public byte[] FullTypeIdBytes {{ get; }}

                                                                                                                              public bool IsUpdatable => {(targetIsUpdatable ? "true" : "false")};

                                                                                                                              public void WriteTypeIdBytes(VoxWriter writer) => writer.WriteTypeIdBytes(FullTypeIdBytes);
                                                                                                                              public void AssertReadTypeId(VoxReader reader) => reader.AssertReadTypeIdBytes(FullTypeIdBytes);
                                                                                                                              public void WriteFull(VoxWriter writer, ref {targetType.Name}{genericArgsStr} self) {{ {writeFullSb} }}
                                                                                                                              public void WriteRaw(VoxWriter writer, ref {targetType.Name}{genericArgsStr} self) {{ {writeRawSb} }}
               ");

            if (targetIsUpdatable) {
               sb.AppendLine($@"
                                                                                                                              public {targetType.Name}{genericArgsStr} ReadFull(VoxReader reader) {{ {targetType.Name}{genericArgsStr} res = new(); ReadFullIntoRef(reader, ref res); return res; }}
                                                                                                                              public {targetType.Name}{genericArgsStr} ReadRaw(VoxReader reader) {{ {targetType.Name}{genericArgsStr} res = new(); ReadRawIntoRef(reader, ref res); return res; }}
                                                                                                                              public void ReadFullIntoRef(VoxReader reader, ref {targetType.Name}{genericArgsStr} self) {{ {readFullSb} }}
                                                                                                                              public void ReadRawIntoRef(VoxReader reader, ref {targetType.Name}{genericArgsStr} self) {{ {readRawSb} }}
                  ");
            } else {
               sb.AppendLine($@"
                                                                                                                              public {targetType.Name} ReadFull(VoxReader reader) {{ {readFullSb} }}
                                                                                                                              public {targetType.Name} ReadRaw(VoxReader reader) {{ {readRawSb} }}
                                                                                                                              public void ReadFullIntoRef(VoxReader reader, ref {targetType.Name} self) => throw new InvalidOperationException({dq}Reading into {targetType.Name} ref is not supported.{dq});
                                                                                                                              public void ReadRawIntoRef(VoxReader reader, ref {targetType.Name} self) => throw new InvalidOperationException({dq}Reading into {targetType.Name} ref is not supported.{dq});
                  ");
            }

            sb.AppendLine($@"
                                                                                                                              void IVoxSerializer.WriteRawObject(VoxWriter writer, object val) {{ {targetType.Name}{genericArgsStr} v = ({targetType.Name}{genericArgsStr})val; WriteRaw(writer, ref v); }}
                                                                                                                              object IVoxSerializer.ReadRawObject(VoxReader reader) => ReadRaw(reader);
                                                                                                                           }}
               ");

            if (ReferenceEquals(type, targetType)) {
               sb.AppendLine($@"
                                                                                                                           /// <summary>Autogenerated</summary>
                                                                                                                           [VoxInternalsAutoSerializedTypeInfoAttribute(GenericSerializerTypeDefinition = typeof({targetType.Name}Serializer{genericArgsUnboundStr}))]
                                                                                                                           public partial {typeKindStr} {targetType.Name}{genericArgsStr} /* : IVoxCustomType<{fullTargetTypeName}>{genericArgsConstraints} */ {{
                                                                                                                              private static {targetType.Name}Serializer{genericArgsStr} GetSerializerInstance(VoxContext vox) => {targetType.Name}Serializer{genericArgsStr}.GetInstance(vox.SerializerContainer);
                                                                                                                              // public {targetType.Name}Serializer{genericArgsStr} Serializer => {targetType.Name}Serializer{genericArgsStr}.Instance;
                                                                                                                              // IVoxSerializer IVoxCustomType.Serializer => Serializer;
                                                                                                                              // IVoxSerializer<{fullTargetTypeName}> IVoxCustomType<{fullTargetTypeName}>.Serializer => Serializer;

                                                                                                                              public void WriteFullInto(VoxWriter writer) {{ var copy = this; GetSerializerInstance(writer.Context).WriteFull(writer, ref copy); }}
                                                                                                                              public void WriteRawInto(VoxWriter writer) {{ var copy = this; GetSerializerInstance(writer.Context).WriteRaw(writer, ref copy); }}
                  ");

               if (targetIsUpdatable) {
                  var copyToThisIfStruct = targetIsStruct && targetIsUpdatable ? " this = copy;" : "";
                  sb.AppendLine($@"
                                                                                                                              public void ReadFullFrom(VoxReader reader) {{ var copy = this; GetSerializerInstance(reader.Context).ReadFullIntoRef(reader, ref copy);{copyToThisIfStruct} }}
                                                                                                                              public void ReadRawFrom(VoxReader reader) {{ var copy = this; GetSerializerInstance(reader.Context).ReadRawIntoRef(reader, ref copy);{copyToThisIfStruct} }}
                     ");
               }

               sb.AppendLine($@"
                                                                                                                           }}");
            }
            sb.AppendLine($@"

                                                                                                                           /// <summary>Autogenerated</summary>
                                                                                                                           public static class VoxGenerated_{targetType.Name}Statics {{
                                                                                                                              public static void WriteFull{targetType.Name}{genericArgsStr}{genericArgsConstraints}(this VoxWriter writer, {fullTargetTypeName} value) {{ var copy = value; {targetType.Name}Serializer{genericArgsStr}.GetInstance(writer.Context).WriteFull(writer, ref value); }}
                                                                                                                              public static void WriteRaw{targetType.Name}{genericArgsStr}{genericArgsConstraints}(this VoxWriter writer, {fullTargetTypeName} value) {{ var copy = value; {targetType.Name}Serializer{genericArgsStr}.GetInstance(writer.Context).WriteRaw(writer, ref value); }}
                                                                                                                              public static {targetType.Name}{genericArgsStr} ReadFull{targetType.Name}{genericArgsStr}{genericArgsConstraints}(this VoxReader reader) => {targetType.Name}Serializer{genericArgsStr}.GetInstance(reader.Context).ReadFull(reader);
                                                                                                                              public static {targetType.Name}{genericArgsStr} ReadRaw{targetType.Name}{genericArgsStr}{genericArgsConstraints}(this VoxReader reader) => {targetType.Name}Serializer{genericArgsStr}.GetInstance(reader.Context).ReadRaw(reader);
                                                                                                                           }}
                                                                                                                        }}

                                                                                                                        namespace {type.ContainingNamespace.ToDisplayString()} {{
               ");

            if (stubDefs.Length > 0) {
               sb.AppendLine($@"
                                                                                                                           /// <summary>Autogenerated</summary>
                                                                                                                           public {(typeIsStatic ? "static" : "/* nonstatic */")} partial {typeKindStr} {type.Name} {{
                                                                                                                              {stubDefs}                                                               
                                                                                                                           }}");
            }

            sb.AppendLine($@"
                                                                                                                        }}");
         }

         var preambleSb = new StringBuilder();
         preambleSb.AppendLine($@"
                                                                                                                        // <auto-generated/>");
         foreach (var x in allUsingImports.OrderBy(x => x)) {
            preambleSb.AppendLine($@"
                                                                                                                        using {x};");
         }

         // Add the source code to the compilation
         var hintName = $"{Path.GetFileName(syntaxTree.FilePath)}.Vox.AutoGenerated.cs";
         context.AddSource(hintName, preambleSb.ToString() + sb.ToString());
      }

   /*
    * var _arr_count = reader.ReadRawInt32();
    * var _arr = new T[_arr_count];
    * for (var _arr_i = 0; _arr_i < _arr_count; _arr_i++) {
    *   var _arr_el_dict_count = reader.ReadRawInt32();
    *   var _arr_el_dict = new Dictionary<int, int[]>();
    *   for (var _arr_el_dict_i = 0; i < _arr_el_dict_count; _arr_el_dict_i++) {
    *     var _arr_el_dict_key = reader.ReadRawInt32();
    *     var _arr_el_dict_value_arr_count = reader.ReadRawInt32();
    *     var _arr_el_dict_value_arr = new int[_arr_el_dict_value_arr_count];
    *     for (var _arr_el_dict_value_arr_i = 0; _arr_el_dict_value_arr_i < _arr_el_dict_value_arr_count; _arr_el_dict_value_arr_i++) {
    *       _arr_el_dict_value_arr[_arr_el_dict_value_arr_i] = reader.ReadRawInt32();
    *     }
    *     _arr_el_dict.add(_arr_el_dict_key, _arr_el_dict_value_arr);
    *   }
    *   _arr[_arr_i] = _arr_el_dict;
    * }
    * field = _arr;
    *
    * --
    *
    * writer.WriteRawInt32(x.Length);
    * foreach (var _arr_el in x.
    */
   string EmitRead(StringBuilder sb, string ind, string baseName, ITypeSymbol t, ITypeSymbol polymorphismAttribute) {
      var isPolymorphic = polymorphismAttribute?.Name.StartsWith("P") ?? false;

      var subpolyAttrs = (polymorphismAttribute as INamedTypeSymbol)?.TypeArguments ?? ImmutableArray<ITypeSymbol>.Empty;
      ITypeSymbol subpolyattr0 = subpolyAttrs.FirstOrDefault() ??
                                 (polymorphismAttribute as IArrayTypeSymbol)?.ElementType;
      ITypeSymbol subpolyattr1 = subpolyAttrs.Skip(1).FirstOrDefault();

      var classification = ClassifyType(t, out var targ0, out var targ1);
      if (classification == TypeClassification.Regular) {
         if (isPolymorphic) {
            return $"reader.ReadPolymorphic<{t.ToDisplayString()}>()";
         } else if (t is ITypeParameterSymbol || (t is INamedTypeSymbol nts && nts.IsGenericType)) {
            var serializerName = GetDependencySerializerName(t);
            return $"{serializerName}.ReadRaw(reader);";
         } else {
            if (t.Name == "Object") Debugger.Break();
            allUsingImports.Add(t.ContainingNamespace.ToDisplayString());
            return $"reader.ReadRaw{t.Name}()";
         }
      } else if (classification == TypeClassification.Array) {
         // a field of type Animal can be assigned Dog (polymorphic)
         // whereas a field of type int[] cannot be assigned anything but an int[] or null.
         // to vox, this is considered nonpolymorphic (we don't need to explicitly serialize the array's type)
         isPolymorphic.AssertEquals(false);

         baseName += "_arr";
         sb.AppendLine($"{ind}var {baseName}_count = reader.ReadRawInt32();");
         sb.AppendLine($"{ind}var {baseName} = {baseName}_count == -1 ? null : {BuildArrayNewString(targ0, $"{baseName}_count")};");
         sb.AppendLine($"{ind}for (var {baseName}_i = 0; {baseName}_i < {baseName}_count; {baseName}_i++) {{");
         {
            var elres = EmitRead(sb, ind + "   ", $"{baseName}_el", targ0, subpolyattr0);
            sb.AppendLine($"{ind}   {baseName}[{baseName}_i] = {elres};");
         }
         sb.AppendLine($"{ind}}}");
         return baseName;
      } else if (classification == TypeClassification.Enumerable) {
         // As with the array field case, we don't attempt to transmit the type of serialized collections;
         // rather, we transmit the contained data and on deserialize create a collection instance that
         // matches the field type (which might be concrete).
         isPolymorphic.AssertEquals(false);

         baseName += "_arr";
         sb.AppendLine($"{ind}var {baseName}_count = reader.ReadRawInt32();");
         var tds = t.ToDisplayString(NullableFlowState.NotNull);
         var tdsCtorArgs = $"{baseName}_count";
         sb.AppendLine($"{ind}var {baseName} = {baseName}_count == -1 ? null : new {tds}({tdsCtorArgs});");
         sb.AppendLine($"{ind}for (var {baseName}_i = 0; {baseName}_i < {baseName}_count; {baseName}_i++) {{");
         {
            var elres = EmitRead(sb, ind + "   ", $"{baseName}_el", targ0, subpolyattr0);
            sb.AppendLine($"{ind}   {baseName}.Add({elres});");
         }
         sb.AppendLine($"{ind}}}");
         return baseName;
      } else if (classification == TypeClassification.DictLike) {
         baseName += "_dict";
         sb.AppendLine($"{ind}var {baseName}_count = reader.ReadRawInt32();");

         var tds = t.ToDisplayString(NullableFlowState.NotNull);
         var isConcurrentDictionary = tds.Contains("ConcurrentDictionary");
         var tdsCtorArgs = isConcurrentDictionary ? "" : $"{baseName}_count";
         var addFunctionName = isConcurrentDictionary ? "TryAdd" : "Add";
         sb.AppendLine($"{ind}var {baseName} = {baseName}_count == -1 ? null : new {tds}({tdsCtorArgs});");
         sb.AppendLine($"{ind}for (var {baseName}_i = 0; {baseName}_i < {baseName}_count; {baseName}_i++) {{");
         {
            var keyres = EmitRead(sb, ind + "   ", $"{baseName}_key", targ0, subpolyattr0);
            sb.AppendLine($"{ind}   var {baseName}_key = {keyres};");

            var valres = EmitRead(sb, ind + "   ", $"{baseName}_val", targ1, subpolyattr1);
            sb.AppendLine($"{ind}   var {baseName}_val = {valres};");
            sb.AppendLine($"{ind}   {baseName}.{addFunctionName}({baseName}_key, {baseName}_val);");
         }
         sb.AppendLine($"{ind}}}");
         return baseName;
      } else if (classification == TypeClassification.TupleLike) {
         var tNts = (INamedTypeSymbol)t;
         baseName += "_tuple";

         var tupleItems = new List<string>();
         for (var i = 0; i < tNts.TupleElements.Length; i++) {
            var tupleElement = tNts.TupleElements[i];
            var elementPolymorphismAttr = subpolyAttrs.Length == 0 ? null : subpolyAttrs[i];
            var elres = EmitRead(sb, ind + "   ", $"{baseName}_item_{i}", tupleElement.Type, elementPolymorphismAttr);
            var elementName = tupleElement.IsExplicitlyNamedTupleElement ? tupleElement.Name : $"Item{i + 1}";
            var tupleVarName = $"{baseName}_item_{i}_res";
            sb.AppendLine($"{ind}var {tupleVarName} = {elres};");
            tupleItems.Add(elementName + ": " + tupleVarName);
         }

         var tupleBody = string.Join(", ", tupleItems);
         sb.AppendLine($"{ind}var {baseName} = ({tupleBody});");
         return baseName;
      }

      throw new NotImplementedException();
   }

   void EmitWrite(StringBuilder sb, string ind, string baseName, string sourceExpression, ITypeSymbol t, ITypeSymbol polymorphismAttribute) {
      var isPolymorphic = polymorphismAttribute?.Name.StartsWith("P") ?? false;

      var subpolyAttrs = (polymorphismAttribute as INamedTypeSymbol)?.TypeArguments ?? ImmutableArray<ITypeSymbol>.Empty;
      ITypeSymbol subpolyattr0 = subpolyAttrs.FirstOrDefault() ??
                                 (polymorphismAttribute as IArrayTypeSymbol)?.ElementType;
      ITypeSymbol subpolyattr1 = subpolyAttrs.Skip(1).FirstOrDefault();

      var classification = ClassifyType(t, out var targ0, out var targ1);
      if (classification == TypeClassification.Regular) {
         if (isPolymorphic) {
            sb.AppendLine($"{ind}writer.WritePolymorphic<{t.ToDisplayString()}>({sourceExpression});");
         } else if (t is ITypeParameterSymbol || (t is INamedTypeSymbol nts && nts.IsGenericType)) {
            var serializerName = GetDependencySerializerName(t);
            baseName += "_copy";
            sb.AppendLine($"{ind}var {baseName} = {sourceExpression};");
            sb.AppendLine($"{ind}{serializerName}.WriteRaw(writer, ref {baseName});");
         } else {
            allUsingImports.Add(t.ContainingNamespace.ToDisplayString());
            sb.AppendLine($"{ind}writer.WriteRaw{t.Name}({sourceExpression});");
         }
      } else if (classification == TypeClassification.Array) {
         // a field of type Animal can be assigned Dog (polymorphic)
         // whereas a field of type int[] cannot be assigned anything but an int[] or null.
         // to vox, this is considered nonpolymorphic (we don't need to explicitly serialize the array's type)
         isPolymorphic.AssertEquals(false);

         baseName += "_arr";
         sb.AppendLine($"{ind}var {baseName} = {sourceExpression};");
         sb.AppendLine($"{ind}if ({baseName} == null) {{");
         sb.AppendLine($"{ind}   writer.WriteRawInt32((int)-1);");
         sb.AppendLine($"{ind}}} else {{");
         sb.AppendLine($"{ind}   writer.WriteRawInt32({baseName}.Length);");
         sb.AppendLine($"{ind}   for (var {baseName}_i = 0; {baseName}_i < {baseName}.Length; {baseName}_i++) {{");
         {
            EmitWrite(sb, ind + "      ", $"{baseName}_el", $"{baseName}[{baseName}_i]", targ0, subpolyattr0);
         }
         sb.AppendLine($"{ind}   }}");
         sb.AppendLine($"{ind}}}");
      } else if (classification == TypeClassification.Enumerable) {
         // We don't attempt to transmit the type of serialized collections; rather, we transmit the contained
         // data and on deserialize create a collection instance that matches the field type (which might be concrete).
         isPolymorphic.AssertEquals(false);

         baseName += "_arr";
         sb.AppendLine($"{ind}var {baseName} = {sourceExpression};");
         sb.AppendLine($"{ind}if ({baseName} == null) {{");
         sb.AppendLine($"{ind}   writer.WriteRawInt32((int)-1);");
         sb.AppendLine($"{ind}}} else {{");
         sb.AppendLine($"{ind}   writer.WriteRawInt32({baseName}.Count);");
         sb.AppendLine($"{ind}   foreach (var {baseName}_el in {baseName}) {{");
         {
            EmitWrite(sb, ind + "      ", $"{baseName}_el", $"{baseName}_el", targ0, subpolyattr0);
         }
         sb.AppendLine($"{ind}   }}");
         sb.AppendLine($"{ind}}}");
      } else if (classification == TypeClassification.DictLike) {
         baseName += "_dict";
         sb.AppendLine($"{ind}var {baseName} = {sourceExpression};");
         sb.AppendLine($"{ind}if ({baseName} == null) {{");
         sb.AppendLine($"{ind}   writer.WriteRawInt32((int)-1);");
         sb.AppendLine($"{ind}}} else {{");
         sb.AppendLine($"{ind}   writer.WriteRawInt32({baseName}.Count);");
         sb.AppendLine($"{ind}   foreach (var {baseName}_kvp in {baseName}) {{");
         {
            EmitWrite(sb, ind + "      ", $"{baseName}_key", $"{baseName}_kvp.Key", targ0, subpolyattr0);
            EmitWrite(sb, ind + "      ", $"{baseName}_value", $"{baseName}_kvp.Value", targ1, subpolyattr1);
         }
         sb.AppendLine($"{ind}   }}");
         sb.AppendLine($"{ind}}}");
      } else if (classification == TypeClassification.TupleLike) {
         var tNts = (INamedTypeSymbol)t;
         baseName += "_tuple";

         sb.AppendLine($"{ind}var {baseName} = {sourceExpression};");

         for (var i = 0; i < tNts.TupleElements.Length; i++) {
            var tupleElement = tNts.TupleElements[i];
            var elementPolymorphismAttr = subpolyAttrs.Length == 0 ? null : subpolyAttrs[i];
            var elementName = tupleElement.IsExplicitlyNamedTupleElement ? tupleElement.Name : $"Item{i + 1}";
            EmitWrite(sb, ind + "   ", $"{baseName}_item_{i}", $"{baseName}.{elementName}", tupleElement.Type, elementPolymorphismAttr);
         }
      } else {
         throw new NotImplementedException();
      }
   }


   public enum TypeClassification {
         Regular,
         Array,
         Enumerable,
         DictLike,
         TupleLike,
      }

      private TypeClassification ClassifyType(ITypeSymbol t, out ITypeSymbol targ0, out ITypeSymbol targ1) {
         if (t is IArrayTypeSymbol ats) {
            targ0 = ats.ElementType;
            targ1 = null;
            return TypeClassification.Array;
         }

         if (t.Name == "String") {
            targ0 = targ1 = null;
            return TypeClassification.Regular;
         }

         if (t.IsTupleType) {
            targ0 = targ1 = null;
            return TypeClassification.TupleLike;
         }

         targ0 = targ1 = null;

         foreach (var iface in t.AllInterfaces) {
            if (iface.Name.IndexOf("Dictionary", StringComparison.OrdinalIgnoreCase) >= 0 && iface.IsGenericType) {
               targ0 = iface.TypeArguments[0];
               targ1 = iface.TypeArguments[1];
               return TypeClassification.DictLike;
            }

            if (iface.Name.IndexOf("IEnumerable", StringComparison.OrdinalIgnoreCase) >= 0 && iface.IsGenericType) {
               targ0 = iface.TypeArguments[0];
            }
         }

         return targ0 != null ? TypeClassification.Enumerable : TypeClassification.Regular;
      }

      private string BuildArrayNewString(ITypeSymbol elType, string indexExpr) {
         var nestedArrayDepth = 0;
         while (elType is IArrayTypeSymbol arts) {
            nestedArrayDepth++;
            elType = arts.ElementType;
         }

         var sb = new StringBuilder();
         sb.Append("new ");
         sb.Append(elType.ToDisplayString(NullableFlowState.NotNull));
         sb.Append($"[{indexExpr}]");
         for (var i = 0; i < nestedArrayDepth; i++) {
            sb.Append($"[]");
         }
         return sb.ToString();
      }
   }
}